<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tugbo Flood Hazard – New Map</title>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet" />
    <style>
        html,
        body,
        #map {
            height: 100%;
            margin: 0
        }

        .panel {
            position: absolute;
            top: 12px;
            left: 12px;
            z-index: 2;
            background: rgba(255, 255, 255, 0.98);
            border: 1px solid #cfd8dc;
            border-radius: 12px;
            box-shadow: 0 3px 14px rgba(0, 0, 0, .12);
            padding: 12px 14px;
            font: 14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial
        }

        .legend .row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px
        }

        .legend .swatch {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            border: 1px solid rgba(0, 0, 0, .28);
            opacity: 1
        }

        .legend .lbl {
            min-width: 96px
        }

        .toggles {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px dashed #cfd8dc
        }

        .toggles label {
            display: block;
            margin-top: 6px
        }

        .credit {
            position: absolute;
            right: 12px;
            bottom: 12px;
            background: rgba(255, 255, 255, .98);
            padding: 6px 8px;
            border: 1px solid #cfd8dc;
            border-radius: 8px;
            font: 12px/1.3 system-ui;
            color: #333
        }

        .popup {
            font: 13px/1.35 system-ui
        }

        .popup table {
            border-collapse: collapse
        }

        .popup td {
            padding: 2px 6px;
            border-bottom: 1px solid #eee;
            vertical-align: top
        }

        .popup td:first-child {
            font-weight: 600;
            white-space: nowrap
        }
    </style>
</head>

<body>
    <div id="map"></div>

    <!-- Legend + Layer toggles -->
    <div class="panel legend" id="legend">
        <div style="font-weight:700;margin-bottom:6px">Flood Hazard (S1)</div>
        <div class="row"><span class="swatch" style="background:hsl(215, 91%, 85%)"></span><span class="lbl">Low</span>
        </div>
        <div class="row"><span class="swatch" style="background:hsl(227, 81%, 76%)"></span><span
                class="lbl">Moderate</span></div>
        <div class="row"><span class="swatch" style="background:hsl(228, 88%, 64%)"></span><span class="lbl">High</span>
        </div>
        <div class="row"><span class="swatch" style="background:hsl(258, 93%, 48%)"></span><span class="lbl">Very
                High</span></div>

        <div class="toggles">
            <label><input type="checkbox" id="toggle-polygons" checked> Polygons</label>
            <label><input type="checkbox" id="toggle-pixels" checked> Pixels</label>
            <label><input type="checkbox" id="toggle-satellite" checked> Satellite</label>
        </div>
    </div>

    <div class="credit">Source: GEE (NASADEM, CHIRPS, Sentinel-1) • Styled in Mapbox Studio</div>

    <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
    <script>
        // ================== CONFIG ==================
        mapboxgl.accessToken = 'pk.eyJ1Ijoia3lhaGFuenp6IiwiYSI6ImNtZGR2YmpqMDA4enIya29zY21nY3hxMjQifQ.U3RNv0EJn1yPHwF41JZALA';
        const STYLE_URL = 'mapbox://styles/kyahanzzz/cmgdd0gv9005f01re5gl09lxu';

        const POLYGON_LAYER_ID = 'tugbo-flood-magnitude-polygon-5jmg4l';
        const PIXEL_LAYER_ID = 'tugbo-hazard-pixels-detail-st-5i34my';
        let SATELLITE_LAYER_ID = 'mapbox-satellite'; // detect or auto-add if missing

        // ---------- Helpers (shared) ----------
        const PIXEL_LABELS = {
            hazard_idx: 'Hazard Index',
            hazard_cls: 'Hazard Class',
            acc: 'Convergence Proxy',
            inv_hand: 'INV HAND',
            inv_slope: 'INV Slope',
            inv_dist: 'INV Distance',
            slope_deg: 'Slope',
            dist_m: 'Distance',
            p_mean: 'Rainfall Mean'
        };
        const CLASS_TEXT = ['(no value)', 'Low', 'Moderate', 'High', 'Very High'];
        function toClassLabel(v) {
            if (v == null || v === '') return '(no value)';
            const n = Number(v);
            if (!Number.isNaN(n)) return CLASS_TEXT[n] || String(v);
            const s = String(v).toLowerCase();
            if (s === 'very high' || s === 'very_high' || s === 'very-high') return 'Very High';
            if (s === 'high') return 'High';
            if (s === 'moderate') return 'Moderate';
            if (s === 'low') return 'Low';
            return String(v);
        }
        function getPixelClass(props) {
            // S1 map uses 'magnitude' for 1..4
            return props.magnitude ?? props.hazard_cls ?? props.class ?? props.level ?? props.rank ?? null;
        }
        function renderPixelTable(p) {
            const get = (o, keys) => { for (const k of keys) if (o[k] !== undefined) return o[k]; };
            const rows = [
                ['hazard_idx', p.hazard_idx !== undefined ? Number(p.hazard_idx).toFixed(2) : undefined],
                ['hazard_cls', (() => { const c = getPixelClass(p); return c !== undefined ? `${c} (${toClassLabel(c)})` : undefined; })()],
                ['acc', p.acc !== undefined ? Number(p.acc).toFixed(2) : undefined],
                ['inv_hand', p.inv_hand !== undefined ? Number(p.inv_hand).toFixed(2) : undefined],
                ['inv_slope', p.inv_slope !== undefined ? Number(p.inv_slope).toFixed(2) : undefined],
                ['inv_dist', p.inv_dist !== undefined ? Number(p.inv_dist).toFixed(2) : undefined],
                ['slope_deg', (() => {
                    const v = get(p, ['slope_deg', 'slope']);
                    return v !== undefined ? `${Number(v).toFixed(1)}°` : undefined;
                })()],
                ['dist_m', (() => {
                    const v = get(p, ['dist_m', 'dist']);
                    return v !== undefined ? `${Math.round(Number(v))} m` : undefined;
                })()],
                ['p_mean', (() => {
                    const v = get(p, ['p_mean', 'precip_mean']);
                    return v !== undefined ? `${Number(v).toFixed(2)} mm/day` : undefined;
                })()]
            ].filter(([, v]) => v !== undefined)
                .map(([k, v]) => `<tr><td>${PIXEL_LABELS[k]}</td><td>${v}</td></tr>`)
                .join('');
            return `<table>${rows}</table>`;
        }

        // ---------- Map setup ----------
        const map = new mapboxgl.Map({
            container: 'map',
            style: STYLE_URL,
            center: [123.639, 12.349],
            zoom: 15
        });
        map.addControl(new mapboxgl.NavigationControl({ visualizePitch: true }), 'top-right');
        map.addControl(new mapboxgl.FullscreenControl(), 'top-right');
        map.addControl(new mapboxgl.ScaleControl({ unit: 'metric' }), 'bottom-right');

        function layerType(id) { try { return map.getLayer(id)?.type } catch { return null } }
        function isVisible(id) { try { return map.getLayoutProperty(id, 'visibility') !== 'none' } catch { return false } }
        function setOpacity(id, value) {
            const t = layerType(id);
            const prop = { 'fill': 'fill-opacity', 'line': 'line-opacity', 'circle': 'circle-opacity', 'symbol': 'icon-opacity', 'raster': 'raster-opacity', 'heatmap': 'heatmap-opacity', 'fill-extrusion': 'fill-extrusion-opacity', 'background': 'background-opacity' }[t];
            if (prop) map.setPaintProperty(id, prop, value);
            if (t === 'symbol') { try { map.setPaintProperty(id, 'text-opacity', value) } catch { } }
        }

        // Satellite handling
        function autoDetectSatelliteLayerId() {
            const candidates = ['mapbox-satellite', 'satellite', 'satellite-imagery', 'satellite-raster', 'satellite-tiles'];
            for (const id of candidates) { if (map.getLayer(id)) return id; }
            const style = map.getStyle();
            if (style?.layers) {
                for (const lyr of style.layers) {
                    if (lyr.type === 'raster') {
                        const idMatch = /satellite/i.test(lyr.id || '');
                        const srcMatch = /satellite/i.test((lyr.source || '') + ' ' + JSON.stringify(lyr));
                        if (idMatch || srcMatch) return lyr.id;
                    }
                }
            }
            return null;
        }
        function ensureSatelliteLayerBottom() {
            let satId = autoDetectSatelliteLayerId() || (map.getLayer(SATELLITE_LAYER_ID) ? SATELLITE_LAYER_ID : null);
            if (!satId) {
                if (!map.getSource('satellite-autogen')) {
                    map.addSource('satellite-autogen', { type: 'raster', url: 'mapbox://mapbox.satellite', tileSize: 256 });
                }
                const firstId = map.getStyle().layers[0].id;
                if (!map.getLayer('satellite-autogen')) {
                    map.addLayer({ id: 'satellite-autogen', type: 'raster', source: 'satellite-autogen', layout: { visibility: 'visible' }, paint: { 'raster-opacity': 1 } }, firstId);
                }
                satId = 'satellite-autogen';
            }
            const firstId = map.getStyle().layers[0].id;
            try { map.moveLayer(satId, firstId); } catch { }
            return satId;
        }

        map.on('load', () => {
            const polyExists = !!map.getLayer(POLYGON_LAYER_ID);
            const pixExists = !!map.getLayer(PIXEL_LAYER_ID);

            const satId = ensureSatelliteLayerBottom();

            // Z-order: Satellite bottom; Pixel very top for clicks; Polygon just under pixel
            if (polyExists) map.moveLayer(POLYGON_LAYER_ID);
            if (pixExists) map.moveLayer(PIXEL_LAYER_ID);
            const firstId = map.getStyle().layers[0].id; try { map.moveLayer(satId, firstId); } catch { }

            // Opacity for readability
            if (polyExists) setOpacity(POLYGON_LAYER_ID, 0.70);
            if (pixExists) setOpacity(PIXEL_LAYER_ID, 0.85);

            // Toggles
            const tPoly = document.getElementById('toggle-polygons');
            const tPix = document.getElementById('toggle-pixels');
            const tSat = document.getElementById('toggle-satellite');
            if (!polyExists) { tPoly.checked = false; tPoly.disabled = true; tPoly.parentElement.title = 'Polygon layer not found'; }
            if (!pixExists) { tPix.checked = false; tPix.disabled = true; tPix.parentElement.title = 'Pixel layer not found'; }
            if (!map.getLayer(satId)) { tSat.checked = false; tSat.disabled = true; tSat.parentElement.title = 'Satellite layer not found'; }

            tPoly.addEventListener('change', e => {
                if (!polyExists) return;
                map.setLayoutProperty(POLYGON_LAYER_ID, 'visibility', e.target.checked ? 'visible' : 'none');
            });
            tPix.addEventListener('change', e => {
                if (!pixExists) return;
                map.setLayoutProperty(PIXEL_LAYER_ID, 'visibility', e.target.checked ? 'visible' : 'none');
            });
            tSat.addEventListener('change', e => {
                if (!map.getLayer(satId)) return;
                map.setLayoutProperty(satId, 'visibility', e.target.checked ? 'visible' : 'none');
            });

            // ---------- Click handler (pixel priority; full table) ----------
            const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: true, maxWidth: '360px' });
            map.on('click', (e) => {
                const layersToQuery = [];
                if (pixExists && isVisible(PIXEL_LAYER_ID)) layersToQuery.push(PIXEL_LAYER_ID);
                if (polyExists && isVisible(POLYGON_LAYER_ID)) layersToQuery.push(POLYGON_LAYER_ID);
                if (!layersToQuery.length) return;

                const feats = map.queryRenderedFeatures(e.point, { layers: layersToQuery });
                if (!feats.length) return;

                const pixelFeat = feats.find(f => f.layer.id === PIXEL_LAYER_ID);
                const polyFeat = feats.find(f => f.layer.id === POLYGON_LAYER_ID);
                const f = pixelFeat || polyFeat;
                const p = f?.properties || {};

                if (e.originalEvent && e.originalEvent.altKey) console.log('Feature properties:', p);

                let html = '';
                if (f.layer.id === PIXEL_LAYER_ID) {
                    html = `<div class="popup">
            <div style="font-weight:700;margin-bottom:6px">Pixel Attributes</div>
            ${renderPixelTable(p)}
          </div>`;
                } else {
                    const cls = getPixelClass(p); // polygons carry 'magnitude' in this style
                    html = `<div class="popup">
            <div style="font-weight:700;margin-bottom:6px">Polygon</div>
            <div><b>Hazard Class:</b> ${toClassLabel(cls)}</div>
          </div>`;
                }
                popup.setLngLat(e.lngLat).setHTML(html).addTo(map);
            });

            // Pointer cursor
            [PIXEL_LAYER_ID, POLYGON_LAYER_ID].forEach(id => {
                if (map.getLayer(id)) {
                    map.on('mouseenter', id, () => map.getCanvas().style.cursor = 'pointer');
                    map.on('mouseleave', id, () => map.getCanvas().style.cursor = '');
                }
            });
        });
    </script>
</body>

</html>
